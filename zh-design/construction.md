# 创建型模式总结

创建型模式: 共有五种: 工厂方法模式,抽象工厂模式,单例模式,建造者模式,原型模式.

单例模式

设计原则：无

常用场景：应用中有对象需要是全局的且唯一

使用概率：99.99999%

复杂度：低

变化点：无

选择关键点：一个对象在应用中出现多个实例是否会引起逻辑上或者是程序上的错误

逆鳞：在以为是单例的情况下，却产生了多个实例

相关设计模式

原型模式：单例模式是只有一个实例，原型模式每拷贝一次都会创造一个新的实例。

-------------------------------
简单工厂模式

设计原则：遵循单一职责、违背开闭原则

常用场景：需要在一堆产品中选择其中一个产品

使用概率：99.99999%

复杂度：低

变化点：产品的种类

选择关键点：一种产品是否可根据某个参数决定它的种类

逆鳞：工厂类不能正常工作

相关设计模式

工厂方法模式：工厂方法模式是简单工厂模式的进一步抽象化，在这两者之间做选择，主要看将工厂进一步抽象化是否有必要，通常情况下，如果工厂的作用仅仅是用来制造产品，则没必要使用工厂方法模式。

--------------------------------------------------------------------------------

工厂方法模式

设计原则：遵循单一职责、依赖倒置、开闭原则

常用场景：一种场景是希望工厂与产品的种类对客户端保持透明，给客户端提供一致的操作，另外一种是不同的工厂和产品可以提供客户端不同的服务或功能

使用概率：60%

复杂度：中低

变化点：工厂与产品的种类

选择关键点：工厂类和产品类是否是同生同灭的关系

逆鳞：无

相关设计模式

抽象工厂模式：工厂方法模式与抽象工厂模式最大的区别在于，在工厂方法模式中，工厂创造的是一个产品，而在抽象工厂模式中，工厂创造的是一个产品族。



--------------------------------------------------------------------------------

抽象工厂模式

设计原则：遵循单一职责、依赖倒置、开闭原则

常用场景：需要一个接口可以提供一个产品族，且不必知道产品的具体种类

使用概率：30%

复杂度：中

变化点：工厂与产品的种类

选择关键点：产品族是否需要一起提供，且是否有一致的接口

逆鳞：无

相关设计模式

建造者模式：两者都是建造一批对象或者说产品，不同的是两者的目的和实现手段，在建造者模式中，是为了复用对象的构建过程而定义了一个指挥者，而在抽象工厂模式中，是为了提供一个这批对象的创建接口而定义了抽象工厂接口。


--------------------------------------------------------------------------------

建造者模式

设计原则：遵循单一职责、开闭原则

常用场景：需要构建一批构建过程相同但表示不同的产品，而构建过程非常复杂

使用概率：10%

复杂度：中

变化点：产品的表示

选择关键点：各个产品的构建过程是否相同

逆鳞：指挥者不能正常工作

--------------------------------------------------------------------------------

原型模式

设计原则：无

常用场景：需要在运行时动态的创建指定实例种类的对象，或是需要复用其状态

使用概率：10%

复杂度：中低

变化点：无

选择关键点：创建出来的对象是否可以立即投入使用

逆鳞：在以为是深度拷贝的情况下，却未实现深度拷贝




PS回答: 1 代理模式: 体现功能复用, 好比现在要增加日志,那么通过aop行为做的话,只需要增加切点和前置操作,而不需要在原本的代码里面进行添加代码的操作,极大的解耦,
2. 工厂方法模式 : 我们通过工厂模式可以实现解耦, 要new一个实体对象是件很谨慎的事情（不是指值对象），不要随便new,所以我们通过工厂去new一个对象,简单工厂是把对象的创建放到一个工厂类中，通过参数来创建不同的对象,而工厂方法：每种产品由一种工厂来创建，一个工厂保存一个new
基本完美，完全遵循 “不改代码”的原则, 而抽象工厂：仅仅是工厂方法的复杂化，保存了多个new大工程才用的上
