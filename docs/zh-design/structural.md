# 结构型设计模式

创建型模式：对对象的实例化过程进行抽象，这使得一个系统可以不用关心这些对象是如何创建，组合，呈现的，对于类创建模式来说通过使用继承改变实例化的类，对于对象创建模式来说通过使用代理来实例化所需要的对象

结构型模式：通过对多个类和对象进行组合得到复杂结构的类，一般使用继承或者成员变量引用形式来实现。

行为型模式：行为模式不仅表达了对象和类，还表达了他们之间的交互，涉及到了对象和算法的分配。


结构型设计模式包括: 代理模式,装饰器模式,适配器模式,外观模式,桥接模式,组合模式,享元模式;

1. 代理模式

设计原则：体现功能复用

常用场景：需要修改或屏蔽某一个或若干个类的部分功能，复用另外一部分功能，可使用静态代理，若是需要拦截一批类中的某些方法，在方法的前后插入一些一致的操作，假设这些类有一致的接口，可使用JDK的动态代理，否则可使用cglib

使用概率：99.99999%

复杂度：中高

变化点：静态代理没有变化点，动态代理的变化点为具有相同切入点的类

选择关键点：静态代理选择的关键点是是否要复用被代理的部分功能，动态代理选择的关键点在于能否在将被代理的这一批类当中，找出相同的切入点

逆鳞：切入点的不稳定

相关设计模式

适配器模式：对于适配器模式当中的定制适配器，它与静态代理有着相似的部分，二者都有复用功能的作用，不同的是，静态代理会修改一部分原有的功能，而适配器往往是全部复用，而且在复用的同时，适配器还会将复用的类适配一个接口


扩充:cglib动态代理

为了解决有一些代理没有接口,那么就需要用Cglib的动态代理模式.因为动态代理只能对接口进行代理

cglib底层使用了ASM来操作字节码生成新的类    ASM使用类似SAX的解析器来实现高性能,

Enhancer 是cglib最常用的一个类, 原理是Enhancer是创建一个被代理对象的子类并且拦截所有方法的调用(包括从Object中继承的toString和hashCode方法.,Enhaner不能够拦截final方法.)


--------------------------------------------------------------------------------

2.适配器模式

设计原则：遵循开闭原则、体现功能复用

常用场景：需要使用一个类的功能，但是该类的接口不符合使用场合要求的接口，可使用定制适配器，又或者是有一个接口定义的行为过多，则可以定义一个缺省适配器，让子类选择性的覆盖适配器的方法

使用概率：40%

复杂度：中

变化点：无

选择关键点：定制适配器的选择关键点在于是否有更加优良的替代方案，缺省适配器的选择关键点在于接口中的方法是否可以不全部提供，且都有缺省方案

逆鳞：无

相关设计模式

装饰器模式：对于适配器模式中的定制适配器与装饰器模式，二者都是使用组合加继承的手段，不同的是，适配器模式的目的在于适配接口，装饰器模式的目的在于动态的添加功能，且可以叠加。


--------------------------------------------------------------------------------

3.装饰器模式


设计原则：遵循迪米特、单一职责、开闭原则，破坏里氏替换，体现功能复用

常用场景：一个类需要动态的添加功能，且这些功能可以相互叠加

使用概率：99.99999%

复杂度：中

变化点：动态添加的功能或者说装饰器

选择关键点：添加的功能是否需要动态组装

逆鳞：无



--------------------------------------------------------------------------------



4.桥接模式

设计原则：遵循单一职责、迪米特、开闭原则，体现功能复用

常用场景：一个对象有多个维度的变化，需要将这些维度抽离出来，让其独立变化

使用概率：20%

复杂度：中高

变化点：维度的扩展与增加

选择关键点：是否可以将对象拆分成多个不相关的维度

逆鳞：无



--------------------------------------------------------------------------------



5.组合模式

设计原则：遵循依赖倒置、开闭原则，破坏接口隔离

常用场景：当有一个结构可以组合成树形结构，且需要向客户端提供一致的操作接口，使得客户端操作忽略简单元素与复杂元素

使用概率：30%


复杂度：中

变化点：节点的数量

选择关键点：对外提供一致操作接口的结构是否可转化为树形结构

逆鳞：结构不稳定或结构中的节点有递归关系



--------------------------------------------------------------------------------



6.享元模式

设计原则：无

常用场景：一些状态相同的对象被大量的重复使用

使用概率：90%

复杂度：中

变化点：无

选择关键点：被共享的对象是否可以将外部状态提取出来

逆鳞：没有将外部状态提取完全



--------------------------------------------------------------------------------



7.外观模式

设计原则：遵循迪米特

常用场景：一个子系统需要对外提供服务

使用概率：60%

复杂度：中

变化点：无

选择关键点：子系统对外提供服务是否需要依赖很多的类

逆鳞：子系统对外提供的服务的变化或子系统本身的不稳定

相关设计模式

中介者模式：二者都是为了处理复杂的耦合关系，不同的是外观模式处理的是类之间复杂的依赖关系，中介者模式处理的是对象之间复杂的交互关系
