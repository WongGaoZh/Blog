
### 数据库调优

https://wonggaozh.github.io/Blog/#/zh-database/3_explian%E4%BD%BF%E7%94%A8

### jvm调优

>jvm选择垃圾处理器
https://wonggaozh.github.io/Blog/#/zh-optimize/15_jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8

>服务器现场问题排查
https://blog.csdn.net/zhang_road/article/details/99746775?spm=1001.2014.3001.5502


### 缓存

#### 缓存双写问题
    先更新数据库，再更新缓存 （两个线程的情况下，可能线程1改了，然后被线程2覆盖了）
    先更新数据库，在删除缓存（使用这种）

    保证最终一致性方案 ：
    通过mq和订阅binlog日志的channl组件来保证最终一致性

    那么在高并发情况下，删除了缓存，那么多个请求会直接打到数据库里面。
    所以添加分布式锁。

### 异步

#### 消息队列-最终一致性

```java

第一是生产者 ： 1.把异步发送改成同步发送，这样就能实时知道结果，
                2.添加异步回调来监听消息。

第二是集群 ： 
现状是异步批量刷盘，按照消息量和时间去刷盘，
Kafka没有同步刷盘，通过partition副本机制和acks机制来解决该问题。
Acks=0 producer不需要等broker响应，就认为消息发送成功了，
Acks=1 leader partition存储了就返回，
Acks=-1 leader收到消息等待ISR的所有的follewer同步完成了才返回。

第三是consumer

采用ack确认机制，同时采用了ack确认机制，可能会产生重复消费，那么就需要采用幂等性来

Rokctmq也是类似原理，生产者就是异步改成同步，同时集群采用同步刷盘和Dledger技术

```


#### 消息队列-有序性
```java

根据CAP（一致，可用，容错）理论，一般分为CP，与AP模型，无法兼得。
强一致性注定需要牺牲效率来保持。
有序性可分为 全局有序与局部有序，区别于有序的颗粒度的不同，扩展性可用性也有所不同，本质上是性能与一致性的权衡。

保证有序性的建议：
消息顺序生产并写入boker阶段
1.多生产者的情况下，需要通过加锁或者cas的方式保证消息产生的有序性。
2.如果是分布式的情况下，多客户端生产消息，需要通过分布式锁来保证有序。
3.通过单独架设一个节点服务，只用于处理消息逻辑顺序与发送（上游节点负责业务与消息打包）。

消息顺序取出阶段
4.kafka，多partition消息需要保持一致性消费，如果采取全局有序的思路，可以通过维护一个全局时间轴，给消息打上时间与类型标签，各种类型的消费者根据时间轴顺序去进行拉取。
如果采用 局部有序性，可以将消息现在在一个partition中以保证局部有序，当然这样的方式可用性扩张性都会相对降低。

消息的消费环节
5.单消费者根据前面提到的消息日期.类型标签，保证顺序消费。（消费者环节全局顺序）
多消费者，按类型划分，每种类型只设一个消费者，以此来保证顺序消费。（局部顺序，比上面单消费者的模型颗粒度更小，扩展性好些）

```

### 池化技术

#### 线程池配置

#### 数据库线程池配置

### 分布式锁 

### 增加硬件资源

直接花钱上资源就完事了
