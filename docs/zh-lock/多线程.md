#
### 多线程

#### 为嘛需要多线程
因为 CPU 实在是太快，太快，太快了，寄存器仅仅能够追的上他的脚步，RAM 和别的挂在各总线上的设备则更是望尘莫及。

#### 多线程概念


#### 多线程原理


#### 用户态和内核态
简单说，Kernel space 是 Linux 内核的运行空间，User space 是用户程序的运行空间。为了安全，它们是隔离的，即使用户的程序崩溃了，内核也不受影响。

代价是

当发生用户态到内核态的切换时，会发生如下过程（本质上是从“用户程序”切换到“内核程序”）
• 设置处理器至内核态。
• 保存当前寄存器（栈指针、程序计数器、通用寄存器）。
• 将栈指针设置指向内核栈地址。
• 将程序计数器设置为一个事先约定的地址上，该地址上存放的是系统调用处理程序的起始地址。
而之后从内核态返回用户态时，又会进行类似的工作。

如何避免频繁切换

用户态和内核态之间的切换有一定的开销，如果频繁发生切换势必会带来很大的开销，所以要想尽一切办法来减少切换。这也是面试常考的问题。

减少线程切换
因为线程的切换会导致用户态和内核态之间的切换，所以减少线程切换也会减少用户态和内核态之间的切换。那么如何减少线程切换呢？
• 无锁并发编程。多线程竞争锁时，加锁、释放锁会导致比较多的上下文切换。（为什么加锁和释放锁会导致上下文切换）
• CAS算法。使用CAS避免加锁，避免阻塞线程
• 使用最少的线程。避免创建不需要的线程
• 协程。在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换


#### 协程和线程的区别
![img.png](assets/img.png)

协程是怎么回事
协程是什么
协程（Coroutine）是用户态的线程。通常创建协程时，会从进程的堆中分配一段内存作为协程的栈。

线程的栈有 8 MB，而协程栈的大小通常只有 KB，而 Go 语言的协程更夸张，只有 2-4KB，非常的轻巧。

协程的优势如下：

节省 CPU：避免系统内核级的线程频繁切换，造成的 CPU 资源浪费。好钢用在刀刃上。而协程是用户态的线程，用户可以自行控制协程的创建于销毁，极大程度避免了系统级线程上下文切换造成的资源浪费。

节约内存：在 64 位的Linux中，一个线程需要分配 8MB 栈内存和 64MB 堆内存，系统内存的制约导致我们无法开启更多线程实现高并发。而在协程编程模式下，可以轻松有十几万协程，这是线程无法比拟的。

稳定性：前面提到线程之间通过内存来共享数据，这也导致了一个问题，任何一个线程出错时，进程中的所有线程都会跟着一起崩溃。

开发效率：使用协程在开发程序之中，可以很方便的将一些耗时的IO操作异步化，例如写文件、耗时 IO 请求等。

协程本质上就是用户态下的线程，所以也有人说协程是 “轻线程”，但我们一定要区分用户态和内核态的区别，很关键。


#### java的锁有几种
java中锁有哪几种: (7种)

公平锁和非公平锁:多个线程按照申请锁的顺序来获取锁

可重入锁: 同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁,可以避免死锁

独享锁/共享锁是一种广义的说法,互斥锁/读写锁就是具体的实现

乐观锁/悲观锁,悲观锁在Java中的使用，就是利用各种锁。乐观锁在Java中的使用，是无锁编程，常常采用的是CAS算法,悲观锁适合写操作非常多的场景，乐观锁适合读操作非常多的场景

分段锁其实是一种锁的设计，并不是具体的一种锁，对于ConcurrentHashMap而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作。

偏向锁/轻量级锁/重量级锁   这三种锁是指锁的状态，并且是针对Synchronized。在Java 5通过引入锁升级的机制来实现高效Synchronized。这三种锁的状态是通过对象监视器在对象头中的字段来表明的
自旋锁

